# CS-230-Operating-Platforms

#Briefly summarize The Gaming Room client and their software requirements. Who was the client? What type of software did they want you to design?
The Gaming Room was the client. hThey seeks to expand their game application, Draw It or Lose It, to multiple platforms including Linux, Mac, and Windows, as well as mobile platforms. 

#What did you do particularly well in developing this documentation?
I effectively structured the evaluation of platforms, highlighting their characteristics, advantages, and weaknesses. I ensured that the documentation was clear, concise, and tailored to the client's specific needs, which helped in making informed decisions.

What about the process of working through a design document did you find helpful when developing the code?
Working through the design document allowed for a systematic analysis of requirements and potential challenges. This process helped me consider how various platforms might affect gameplay experience, scalability, and user engagement.

If you could choose one part of your work on these documents to revise, what would you pick? How would you improve it?
If I could revise one part, it would be the section on user interface considerations for each platform. I would expand it to include more detailed wireframes and user flow diagrams to better visualize how the game would function across different environments.

How did you interpret the user’s needs and implement them into your software design? Why is it so important to consider the user’s needs when designing?
I took note of the customer's requirements and vision for the application. Considering user needs is crucial as it directly impacts user engagement and satisfaction. The design ensures higher adoption rates and enhances the overall gameplay experience.

How did you approach designing software? What techniques or strategies would you use in the future to analyze and design a similar software application?
I think using established patterns from the start helps everyone understand what we want to achieve while giving developers the freedom to choose how to build it. Breaking down big features into smaller API-driven microservices lets us build complex systems step by step. First, defining data structures and processes helps guide other work, like designing the user interface. I’d use similar strategies, like creating modular designs, using patterns, drawing domain models, and making sure there’s a clear connection between user needs and technical details.
